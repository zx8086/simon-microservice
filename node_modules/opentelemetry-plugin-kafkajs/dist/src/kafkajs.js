"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.KafkaJsPlugin = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const context_base_1 = require("@opentelemetry/context-base");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const shimmer = __importStar(require("shimmer"));
const version_1 = require("./version");
const propagtor_1 = require("./propagtor");
class KafkaJsPlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('opentelemetry-plugin-kafkajs', version_1.VERSION);
        this.moduleName = moduleName;
    }
    patch() {
        var _a, _b, _c, _d;
        this._logger.debug('kafkajs: patch kafkajs plugin');
        shimmer.wrap((_b = (_a = this._moduleExports) === null || _a === void 0 ? void 0 : _a.Kafka) === null || _b === void 0 ? void 0 : _b.prototype, 'producer', this._getProducerPatch.bind(this));
        shimmer.wrap((_d = (_c = this._moduleExports) === null || _c === void 0 ? void 0 : _c.Kafka) === null || _d === void 0 ? void 0 : _d.prototype, 'consumer', this._getConsumerPatch.bind(this));
        return this._moduleExports;
    }
    unpatch() {
        var _a, _b, _c, _d;
        this._logger.debug('kafkajs: unpatch kafkajs plugin');
        shimmer.unwrap((_b = (_a = this._moduleExports) === null || _a === void 0 ? void 0 : _a.Kafka) === null || _b === void 0 ? void 0 : _b.prototype, 'producer');
        shimmer.unwrap((_d = (_c = this._moduleExports) === null || _c === void 0 ? void 0 : _c.Kafka) === null || _d === void 0 ? void 0 : _d.prototype, 'consumer');
    }
    _getConsumerPatch(original) {
        const thisPlugin = this;
        return function (...args) {
            const newConsumer = original.apply(this, arguments);
            shimmer.wrap(newConsumer, 'run', thisPlugin._getConsumerRunPatch.bind(thisPlugin));
            return newConsumer;
        };
    }
    _getProducerPatch(original) {
        const thisPlugin = this;
        return function (...args) {
            const newProducer = original.apply(this, arguments);
            shimmer.wrap(newProducer, 'sendBatch', thisPlugin._getProducerSendBatchPatch.bind(thisPlugin));
            shimmer.wrap(newProducer, 'send', thisPlugin._getProducerSendPatch.bind(thisPlugin));
            return newProducer;
        };
    }
    _getConsumerRunPatch(original) {
        const thisPlugin = this;
        return function (config) {
            if (config === null || config === void 0 ? void 0 : config.eachMessage) {
                shimmer.wrap(config, 'eachMessage', thisPlugin._getConsumerEachMessagePatch.bind(thisPlugin));
            }
            if (config === null || config === void 0 ? void 0 : config.eachBatch) {
                shimmer.wrap(config, 'eachBatch', thisPlugin._getConsumerEachBatchPatch.bind(thisPlugin));
            }
            return original.call(this, config);
        };
    }
    _getConsumerEachMessagePatch(original) {
        const thisPlugin = this;
        return function (payload) {
            const propagatedContext = api_1.propagation.extract(context_base_1.ROOT_CONTEXT, payload.message.headers, propagtor_1.bufferTextMapGetter);
            const span = thisPlugin._startConsumerSpan(payload.topic, payload.message, semantic_conventions_1.MessagingOperationName.PROCESS, propagatedContext);
            const eachMessagePromise = api_1.context.with(api_1.setSpan(api_1.context.active(), span), () => {
                return original.apply(this, arguments);
            });
            return thisPlugin._endSpansOnPromise([span], eachMessagePromise);
        };
    }
    _getConsumerEachBatchPatch(original) {
        const thisPlugin = this;
        return function (payload) {
            // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers
            const receivingSpan = thisPlugin._startConsumerSpan(payload.batch.topic, undefined, semantic_conventions_1.MessagingOperationName.RECEIVE, context_base_1.ROOT_CONTEXT);
            return api_1.context.with(api_1.setSpan(api_1.context.active(), receivingSpan), () => {
                const spans = payload.batch.messages.map((message) => {
                    var _a;
                    const propagatedContext = api_1.propagation.extract(context_base_1.ROOT_CONTEXT, message.headers, propagtor_1.bufferTextMapGetter);
                    const spanContext = (_a = api_1.getSpan(propagatedContext)) === null || _a === void 0 ? void 0 : _a.context();
                    let origSpanLink;
                    if (spanContext) {
                        origSpanLink = {
                            context: spanContext,
                        };
                    }
                    return thisPlugin._startConsumerSpan(payload.batch.topic, message, semantic_conventions_1.MessagingOperationName.PROCESS, undefined, origSpanLink);
                });
                const batchMessagePromise = original.apply(this, arguments);
                spans.unshift(receivingSpan);
                return thisPlugin._endSpansOnPromise(spans, batchMessagePromise);
            });
        };
    }
    _getProducerSendBatchPatch(original) {
        const thisPlugin = this;
        return function (batch) {
            const spans = batch.topicMessages.flatMap((topicMessage) => topicMessage.messages.map((message) => thisPlugin._startProducerSpan(topicMessage.topic, message)));
            const origSendResult = original.apply(this, arguments);
            return thisPlugin._endSpansOnPromise(spans, origSendResult);
        };
    }
    _getProducerSendPatch(original) {
        const thisPlugin = this;
        return function (record) {
            const spans = record.messages.map((message) => {
                return thisPlugin._startProducerSpan(record.topic, message);
            });
            const origSendResult = original.apply(this, arguments);
            return thisPlugin._endSpansOnPromise(spans, origSendResult);
        };
    }
    _endSpansOnPromise(spans, sendPromise) {
        return sendPromise
            .catch((reason) => {
            let errorMessage;
            if (typeof reason === 'string')
                errorMessage = reason;
            else if (typeof reason === 'object' && reason.hasOwnProperty('message'))
                errorMessage = reason.message;
            spans.forEach((span) => span.setStatus({
                code: api_1.StatusCode.ERROR,
                message: errorMessage,
            }));
            throw reason;
        })
            .finally(() => {
            spans.forEach((span) => span.end());
        });
    }
    _startConsumerSpan(topic, message, operation, context, link) {
        var _a;
        const span = this._tracer.startSpan(topic, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: {
                [semantic_conventions_1.MessagingAttribute.MESSAGING_SYSTEM]: 'kafka',
                [semantic_conventions_1.MessagingAttribute.MESSAGING_DESTINATION]: topic,
                [semantic_conventions_1.MessagingAttribute.MESSAGING_DESTINATION_KIND]: 'topic',
                [semantic_conventions_1.MessagingAttribute.MESSAGING_OPERATION]: operation,
            },
            links: link ? [link] : [],
        }, context);
        if (((_a = this._config) === null || _a === void 0 ? void 0 : _a.consumerHook) && message) {
            this._safeExecute([], () => this._config.consumerHook(span, topic, message), false);
        }
        return span;
    }
    _startProducerSpan(topic, message) {
        var _a, _b;
        const span = this._tracer.startSpan(topic, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [semantic_conventions_1.MessagingAttribute.MESSAGING_SYSTEM]: 'kafka',
                [semantic_conventions_1.MessagingAttribute.MESSAGING_DESTINATION]: topic,
                [semantic_conventions_1.MessagingAttribute.MESSAGING_DESTINATION_KIND]: 'topic',
            },
        });
        message.headers = (_a = message.headers) !== null && _a !== void 0 ? _a : {};
        api_1.propagation.inject(api_1.setSpan(api_1.context.active(), span), message.headers);
        if ((_b = this._config) === null || _b === void 0 ? void 0 : _b.producerHook) {
            this._safeExecute([], () => this._config.producerHook(span, topic, message), false);
        }
        return span;
    }
    _safeExecute(spans, execute, rethrow) {
        try {
            return execute();
        }
        catch (error) {
            if (rethrow) {
                spans.forEach((span) => {
                    span.setStatus({
                        code: api_1.StatusCode.ERROR,
                        message: error === null || error === void 0 ? void 0 : error.message,
                    });
                    span.end();
                });
                throw error;
            }
            this._logger.error('caught error ', error);
        }
    }
}
exports.KafkaJsPlugin = KafkaJsPlugin;
exports.plugin = new KafkaJsPlugin('kafkajs');
//# sourceMappingURL=kafkajs.js.map