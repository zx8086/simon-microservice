"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketIoInstrumentation = void 0;
const api_1 = require("@opentelemetry/api");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const types_1 = require("./types");
const version_1 = require("./version");
const is_promise_1 = __importDefault(require("is-promise"));
const reservedEvents = ['connect', 'connect_error', 'disconnect', 'disconnecting', 'newListener', 'removeListener'];
class SocketIoInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
        var _a;
        super('opentelemetry-instrumentation-socket.io', version_1.VERSION, normalizeConfig(config));
        if (config.filterHttpTransport) {
            const httpInstrumentationConfig = config.filterHttpTransport.httpInstrumentation.getConfig();
            if (!Array.isArray(httpInstrumentationConfig.ignoreIncomingPaths)) {
                httpInstrumentationConfig.ignoreIncomingPaths = [];
            }
            httpInstrumentationConfig.ignoreIncomingPaths.push((_a = config.filterHttpTransport.socketPath) !== null && _a !== void 0 ? _a : types_1.defaultSocketIoPath);
            config.filterHttpTransport.httpInstrumentation.setConfig(httpInstrumentationConfig);
        }
    }
    init() {
        const socketInstrumentation = new instrumentation_1.InstrumentationNodeModuleFile('socket.io/dist/socket.js', ['>=3'], (moduleExports, moduleVersion) => {
            var _a, _b, _c, _d;
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Socket`);
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Socket) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.on)) {
                this._unwrap(moduleExports.Socket.prototype, 'on');
            }
            this._wrap(moduleExports.Socket.prototype, 'on', this._patchOn(moduleVersion));
            if (instrumentation_1.isWrapped((_d = (_c = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Socket) === null || _c === void 0 ? void 0 : _c.prototype) === null || _d === void 0 ? void 0 : _d.emit)) {
                this._unwrap(moduleExports.Socket.prototype, 'emit');
            }
            this._wrap(moduleExports.Socket.prototype, 'emit', this._patchEmit(moduleVersion));
            return moduleExports;
        }, (moduleExports) => {
            var _a, _b, _c, _d;
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Socket) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.on)) {
                this._unwrap(moduleExports.Socket.prototype, 'on');
            }
            if (instrumentation_1.isWrapped((_d = (_c = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Socket) === null || _c === void 0 ? void 0 : _c.prototype) === null || _d === void 0 ? void 0 : _d.emit)) {
                this._unwrap(moduleExports.Socket.prototype, 'emit');
            }
            return moduleExports;
        });
        const broadcastOperatorInstrumentation = new instrumentation_1.InstrumentationNodeModuleFile('socket.io/dist/broadcast-operator.js', ['>=4'], (moduleExports, moduleVersion) => {
            var _a, _b;
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} StrictEventEmitter`);
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.BroadcastOperator) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.BroadcastOperator.prototype, 'emit');
            }
            this._wrap(moduleExports.BroadcastOperator.prototype, 'emit', this._patchEmit(moduleVersion));
            return moduleExports;
        }, (moduleExports) => {
            var _a, _b;
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.BroadcastOperator) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.BroadcastOperator.prototype, 'emit');
            }
            return moduleExports;
        });
        const namespaceInstrumentation = new instrumentation_1.InstrumentationNodeModuleFile('socket.io/dist/namespace.js', ['<4'], (moduleExports, moduleVersion) => {
            var _a, _b;
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Namespace`);
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Namespace) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.Namespace.prototype, 'emit');
            }
            this._wrap(moduleExports.Namespace.prototype, 'emit', this._patchEmit(moduleVersion));
            return moduleExports;
        }, (moduleExports) => {
            var _a, _b;
            if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Namespace) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.Namespace.prototype, 'emit');
            }
        });
        const socketInstrumentationLegacy = new instrumentation_1.InstrumentationNodeModuleFile('socket.io/lib/socket.js', ['2'], (moduleExports, moduleVersion) => {
            var _a, _b;
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Socket`);
            if (instrumentation_1.isWrapped((_a = moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.on)) {
                this._unwrap(moduleExports.prototype, 'on');
            }
            this._wrap(moduleExports.prototype, 'on', this._patchOn(moduleVersion));
            if (instrumentation_1.isWrapped((_b = moduleExports.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.prototype, 'emit');
            }
            this._wrap(moduleExports.prototype, 'emit', this._patchEmit(moduleVersion));
            return moduleExports;
        }, (moduleExports) => {
            var _a, _b;
            if (instrumentation_1.isWrapped((_a = moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.on)) {
                this._unwrap(moduleExports.prototype, 'on');
            }
            if (instrumentation_1.isWrapped((_b = moduleExports.prototype) === null || _b === void 0 ? void 0 : _b.emit)) {
                this._unwrap(moduleExports.prototype, 'emit');
            }
            return moduleExports;
        });
        const namespaceInstrumentationLegacy = new instrumentation_1.InstrumentationNodeModuleFile('socket.io/lib/namespace.js', ['2'], (moduleExports, moduleVersion) => {
            var _a;
            if (moduleExports === undefined || moduleExports === null) {
                return moduleExports;
            }
            api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Namespace`);
            if (instrumentation_1.isWrapped((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.emit)) {
                this._unwrap(moduleExports.prototype, 'emit');
            }
            this._wrap(moduleExports.prototype, 'emit', this._patchEmit(moduleVersion));
            return moduleExports;
        }, (moduleExports) => {
            var _a;
            if (instrumentation_1.isWrapped((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.emit)) {
                this._unwrap(moduleExports.prototype, 'emit');
            }
        });
        return [
            new instrumentation_1.InstrumentationNodeModuleDefinition('socket.io', ['>=3'], (moduleExports, moduleVersion) => {
                var _a, _b;
                if (moduleExports === undefined || moduleExports === null) {
                    return moduleExports;
                }
                api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Server`);
                if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Server) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.on)) {
                    this._unwrap(moduleExports.Server.prototype, 'on');
                }
                this._wrap(moduleExports.Server.prototype, 'on', this._patchOn(moduleVersion));
                return moduleExports;
            }, (moduleExports, moduleVersion) => {
                var _a, _b;
                if (instrumentation_1.isWrapped((_b = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Server) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.on)) {
                    this._unwrap(moduleExports.Server.prototype, 'on');
                }
                return moduleExports;
            }, [broadcastOperatorInstrumentation, namespaceInstrumentation, socketInstrumentation]),
            new instrumentation_1.InstrumentationNodeModuleDefinition('socket.io', ['2'], (moduleExports, moduleVersion) => {
                var _a;
                if (moduleExports === undefined || moduleExports === null) {
                    return moduleExports;
                }
                api_1.diag.debug(`socket.io instrumentation: applying patch to socket.io@${moduleVersion} Server`);
                if (instrumentation_1.isWrapped((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.on)) {
                    this._unwrap(moduleExports.prototype, 'on');
                }
                this._wrap(moduleExports.prototype, 'on', this._patchOn(moduleVersion));
                return moduleExports;
            }, (moduleExports, moduleVersion) => {
                var _a;
                if (instrumentation_1.isWrapped((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.prototype) === null || _a === void 0 ? void 0 : _a.on)) {
                    this._unwrap(moduleExports.prototype, 'on');
                }
                return moduleExports;
            }, [namespaceInstrumentationLegacy, socketInstrumentationLegacy]),
        ];
    }
    setConfig(config = {}) {
        return super.setConfig(normalizeConfig(config));
    }
    _patchOn(moduleVersion) {
        const self = this;
        return (original) => {
            return function (ev, originalListener) {
                if (!self._config.traceReserved && reservedEvents.includes(ev)) {
                    return original.apply(this, arguments);
                }
                if (self._config.onIgnoreEventList.includes(ev)) {
                    return original.apply(this, arguments);
                }
                const wrappedListener = function (...args) {
                    var _a, _b;
                    const eventName = ev;
                    const defaultNamespace = '/';
                    const namespace = this.name || ((_b = (_a = this.adapter) === null || _a === void 0 ? void 0 : _a.nsp) === null || _b === void 0 ? void 0 : _b.name);
                    const destination = namespace === defaultNamespace ? eventName : `${namespace} ${eventName}`;
                    const span = self.tracer.startSpan(`${destination} ${semantic_conventions_1.MessagingOperationValues.RECEIVE}`, {
                        kind: api_1.SpanKind.CONSUMER,
                        attributes: {
                            [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'socket.io',
                            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: namespace,
                            [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: semantic_conventions_1.MessagingOperationValues.RECEIVE,
                            [types_1.SocketIoInstrumentationAttributes.SOCKET_IO_EVENT_NAME]: eventName,
                        },
                    });
                    if (self._config.onHook) {
                        instrumentation_1.safeExecuteInTheMiddle(() => self._config.onHook(span, { moduleVersion, payload: args }), (e) => {
                            if (e)
                                api_1.diag.error(`socket.io instrumentation: onHook error`, e);
                        }, true);
                    }
                    return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => self.endSpan(() => originalListener.apply(this, arguments), span));
                };
                return original.apply(this, [ev, wrappedListener]);
            };
        };
    }
    endSpan(traced, span) {
        try {
            const result = traced();
            if (is_promise_1.default(result)) {
                return Promise.resolve(result)
                    .catch((err) => {
                    if (err) {
                        if (typeof err === 'string') {
                            span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err });
                        }
                        else {
                            span.recordException(err);
                            span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err === null || err === void 0 ? void 0 : err.message });
                        }
                    }
                    throw err;
                })
                    .finally(() => span.end());
            }
            else {
                span.end();
                return result;
            }
        }
        catch (error) {
            span.recordException(error);
            span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error === null || error === void 0 ? void 0 : error.message });
            span.end();
            throw error;
        }
    }
    _patchEmit(moduleVersion) {
        const self = this;
        return (original) => {
            return function (ev, ...args) {
                var _a, _b, _c, _d, _e;
                if (!self._config.traceReserved && reservedEvents.includes(ev)) {
                    return original.apply(this, arguments);
                }
                if (self._config.emitIgnoreEventList.includes(ev)) {
                    return original.apply(this, arguments);
                }
                const messagingSystem = 'socket.io';
                const eventName = ev;
                const attributes = {
                    [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: messagingSystem,
                    [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MessagingDestinationKindValues.TOPIC,
                    [types_1.SocketIoInstrumentationAttributes.SOCKET_IO_EVENT_NAME]: eventName,
                };
                let rooms = this.rooms || this._rooms || ((_a = this.sockets) === null || _a === void 0 ? void 0 : _a._rooms) || ((_b = this.sockets) === null || _b === void 0 ? void 0 : _b.rooms) || [];
                // Some of the attributes above are of Set type. Convert it.
                if (!Array.isArray(rooms)) {
                    rooms = Array.from(rooms);
                }
                // only for v2: this.id is only set for v2. That's to mimic later versions which have this.id in the rooms Set.
                if (rooms.length === 0 && this.id) {
                    rooms.push(this.id);
                }
                if (rooms.length) {
                    attributes[types_1.SocketIoInstrumentationAttributes.SOCKET_IO_ROOMS] = rooms;
                }
                const namespace = this.name || ((_d = (_c = this.adapter) === null || _c === void 0 ? void 0 : _c.nsp) === null || _d === void 0 ? void 0 : _d.name) || ((_e = this.sockets) === null || _e === void 0 ? void 0 : _e.name);
                if (namespace) {
                    attributes[types_1.SocketIoInstrumentationAttributes.SOCKET_IO_NAMESPACE] = namespace;
                    attributes[semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION] = namespace;
                }
                const spanRooms = rooms.length ? `[${rooms.join()}]` : '';
                const span = self.tracer.startSpan(`${namespace}${spanRooms} send`, {
                    kind: api_1.SpanKind.PRODUCER,
                    attributes,
                });
                if (self._config.emitHook) {
                    instrumentation_1.safeExecuteInTheMiddle(() => self._config.emitHook(span, { moduleVersion, payload: args }), (e) => {
                        if (e)
                            api_1.diag.error(`socket.io instrumentation: emitHook error`, e);
                    }, true);
                }
                try {
                    return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => original.apply(this, arguments));
                }
                catch (error) {
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error.message });
                    throw error;
                }
                finally {
                    span.end();
                }
            };
        };
    }
}
exports.SocketIoInstrumentation = SocketIoInstrumentation;
const normalizeConfig = (config) => {
    config = Object.assign({}, config);
    if (!Array.isArray(config.emitIgnoreEventList)) {
        config.emitIgnoreEventList = [];
    }
    if (!Array.isArray(config.onIgnoreEventList)) {
        config.onIgnoreEventList = [];
    }
    return config;
};
//# sourceMappingURL=socket.io.js.map